---
title: 사내 프로젝트 패키징 리뷰
date: '2024-11-15'
tags: ['nextJS', 'devOps', 'docker', 'debian']
draft: false
summary: 사내 프로젝트의 패키징 작업을 완료해서 이와 관련된 후기에 대한 경험을 남겨보려고 합니다.
---

## 서론

이전 글을 작성하면서 문제가 거의 없을 줄 알았는데, 여러 트러블 슈팅이 존재했던 경험이었던 것 같습니다. 그래도 어찌저찌 패키징 작업을 완료했고, 성공적으로 시연에 성공하여 나름 인정을 받을 수 있었던 것 같습니다. 이와 관련하여 글을 좀 작성해보려고 합니다.

<TOCInline toc={props.toc} exclude="서론" />

## AMD64 VS ARM64

맥북에 대해 조금이라도 들어보셨다면 아시겠지만, 최근부터 맥은 CPU를 인텔이 아닌 자체 개발 칩셋을 사용하기 시작했습니다. 물론 성능도 좋고, 전력 효율도 비약적으로 좋다고 하지만, `X86-AMD64`와 같은 아키텍쳐를 가진 시스템 환경과는 호환이 되지 않는다는 단점이 있습니다. 물론 로제타와 같은 에뮬레이터가 존재하지만 속도는 `ARM64` 네이티브 환경에 비해 떨어지는 것이 사실이죠.

### 그래서 뭐가 문제인데?

저희 회사는 `AWS`를 사용하고 있고, 인스턴스가 `AMD64`를 기반으로 한 운영체제를 탑재하고 있습니다. 온프레미스 환경에서 설치해야 할 서버 PC도 마찬가지로 대부분이 그렇죠. 그렇기 때문에 실리콘 맥에 **네이티브**하게 빌드된 도커 이미지 파일을 곧바로 푸쉬할 수 없다는 것이 단점이었습니다.

관련해서 솔루션을 찾아봤는데, `docker buildx`와 `--platform=amd64`와 같은 옵션이 있어서 변환하는 것은 기술적으로 문제가 되지 않았습니다. 몇 번의 테스트 결과 서버에서 정상적으로 동작하는 것을 확인했습니다. 하지만 모든 작업에는 `trade-off`가 존재하듯이 이번에도 이슈가 하나 발생하긴 했습니다.

### 도커 빌드 프로세스

[이전 글](/blog/FE/NextJS%20도커%20적용기)에도 나와있듯이 `.Dockerfile`의 내부 로직을 다시 간단하게 요약해보면 아래와 같습니다.

```bash
1. alpine 이미지를 기반으로 빌드 환경을 구성
2. package install
3. build
```

여기서 문제는 `install & build` 하는 시간이 너무 오래걸린다는 것이었습니다. 물론 레이어를 나눠서 최대한 캐싱 데이터를 활용할 수 있도록 구성하였지만, 저희 사내 프로젝트의 페이지들은 모두 패키지 기반으로 구성되어 있기 때문에 바뀐 페이지를 계속해서 테스트 해봐야 하는 상황에서는 캐싱 데이터를 거의 활용하기가 힘들었습니다. 근본적으로 패키지 `install` 하는 시간이 로컬에서도 2분 가까이 걸리는 정도면 말 다했죠. 결론적으로 시간을 측정했을 때의 결과는 아래와 같았습니다.

|   Task   |   Local   |   AMD64   |   ARM64   |
|:--------:|:---------:|:---------:|:---------:|
| **Install** |   1-2분   |   2-3분   |  10-12분  |
| **Build**   |  1분 20초  |  1분 30초  |   9-10분  |

### 그래서 어떻게 해결했냐고요?

완벽한 해결책을 찾지 못했습니다. 아무리 캐싱을 하면 안되고, 빌드도 무조건 재빌드 해야 하는 상황에서 어찌 방법이 있겠습니까. 하지만 대책이 한가지 존재하기는 했습니다. 정말 다행히도 사내에 `Intel Mac`이 하나 존재했는데, 이를 활용해서 빌드를 해보니 시간을 많이 줄일 수 있었습니다.

|   Install   |   Build   |
|:-----------:|:---------:|
|   6분 30초  |  5분 30초 |

더 줄일 수 있을지는 모르겠지만, 현재까지는 이 정도가 한계인 듯합니다. 이와 관련해서 대표님과 상의를 조금 했었는데, `AMD64` 기반의 인스턴스를 하나 파서 자동화 배포 느낌으로 도커 이미지 빌드머신을 만드는 방법이 있을 것 같다는 답변을 들었습니다. 만약 그렇게 된다면 새롭게 글을 한 번 작성하도록 하겠습니다.

## Version Tagging

두 번째는 다소 가벼운 이슈인데, 바로 도커 이미지의 버전 태깅입니다. 사실 지금까지 `latest`로만 빌드를 해왔는데, 이제는 `tag`를 붙여서 관리를 해야 한다는 요구사항을 받았습니다. 그러면 그냥 붙이면 되는거 아냐? 라고 생각할수도 있는데, 하나 고려할 점이 있었습니다.

### `:latest` 태그에 관하여

저는 처음에 `latest` 태그가 어떠한 의미를 지녔다고 생각하고 있었습니다. 예를 들어 `1.0.x`로 버전 태깅을 한다고 했을 때 `1.0.4` 버전이 제일 최신이라면 `latest` 태그를 붙이기만 하면 `pull`을 해오는 상황에서 자동으로 `1.0.4` 버전을 최신으로 인식할 줄 알았습니다.

하지만 그렇지 않더군요, `latest`는 단순히 하나의 `tagging`인 것이고, 만약 `docker repository`의 마지막으로 `push`한 `latest` 버전이 `1.0.3`이라면 `1.0.4` 버전을 사용하지 않고, `1.0.3` 버전을 가져오게 되는 방식으로 동작하는 것을 확인했습니다. 그래서 이를 해결하기 위해 버전 태깅을 두 번하는 방식으로 `Makefile`을 수정했습니다. 아래와 같은 방식으로 말이죠.

```bash:Makefile
docker build --platform=linux/amd64 -t company/product:latest -t company/product:1.0.4 .
```

사실 빌드를 두 번 하는 것이 아닌, 태깅을 두 번 하는 것이기 때문에 실질적으로 큰 상관은 없겠다 싶어서 우선 이렇게 짜놨습니다. 이후에 더 좋은 방법이 있다면 그때 수정 예정입니다.

## 마무리

사실 작성할 내용이 조금 더 있기는 한데, 이건 사내 보안 이슈가 있을 것 같아서 작성을 하다가 멈췄습니다. 어쨋든 이렇게 `Docker`를 독학하면서 사내 프로젝트에 도입할 수 있게 된 기회는 정말 좋았던 것 같습니다. 그럼 이만 글을 마치도록 하겠습니다.